package warp

import (
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/base64"
	"log"
	"math/big"
	"os"
	"reflect"
	"testing"

	"github.com/fxamacker/cbor/v2"
)

var goodP256Key *ecdsa.PrivateKey
var goodP256X cbor.RawMessage
var goodP256Y cbor.RawMessage
var goodP256COSE *COSEKey
var goodP256Raw cbor.RawMessage
var goodP256CertBytes []byte
var goodP256Cert *x509.Certificate
var goodP384Key *ecdsa.PrivateKey
var goodP521Key *ecdsa.PrivateKey
var good1024Key *rsa.PrivateKey
var good2048Key *rsa.PrivateKey
var good4096Key *rsa.PrivateKey
var good25519Pub ed25519.PublicKey
var good25519Priv ed25519.PrivateKey

//var knownP256Raw []byte
var mockCredentialID string
var mockRawCredentialID []byte
var mockCredential *testCred
var mockUser *testUser
var mockAttestedCredentialData AttestedCredentialData
var mockRawAttestedCredentialData []byte
var mockRawAuthData []byte
var mockAuthData AuthenticatorData
var mockRawNoneAttestationObject cbor.RawMessage
var mockRawFIDOU2FAttestationObject cbor.RawMessage
var mockRawPackedAttestationObject cbor.RawMessage
var mockNoneAttestationObject AttestationObject
var goodPackedAttStmt []byte
var goodFIDOU2FAttStmt []byte
var mockCreateClientDataJSON []byte
var mockCreateClientDataJSONHash [32]byte

var predictableBytes []byte

type predictableReader struct{}

func (predictableReader) Read(p []byte) (n int, err error) {
	b := bytes.NewBuffer(
		predictableBytes,
	)
	return b.Read(p)
}

func TestMain(m *testing.M) {
	var err error

	h := crypto.SHA256.New()
	predictableBytes = h.Sum(nil)
	for i := 0; i < 0x100; i++ {
		h = crypto.SHA256.New()
		h.Write([]byte{byte(i)})
		predictableBytes = append(predictableBytes, h.Sum(nil)...)
	}

	goodP256Key, err = ecdsa.GenerateKey(elliptic.P256(), &predictableReader{})
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	goodP384Key, err = ecdsa.GenerateKey(elliptic.P384(), rand.Reader)
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	goodP521Key, err = ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	good1024Key, err = rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	good2048Key, err = rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	good4096Key, err = rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	good25519Pub, good25519Priv, err = ed25519.GenerateKey(rand.Reader)
	if err != nil {
		log.Fatalf("Key gen error: %v", err)
	}

	em, _ := cbor.CTAP2EncOptions().EncMode()

	goodP256X, err = em.Marshal(goodP256Key.PublicKey.X.Bytes())
	if err != nil {
		log.Fatalf("X marshal err: %v", err)
	}
	goodP256Y, err = em.Marshal(goodP256Key.PublicKey.Y.Bytes())
	if err != nil {
		log.Fatalf("Y marshal err: %v", err)
	}

	goodP256COSE = &COSEKey{
		Kty:       int(KeyTypeEC2),
		Alg:       int(AlgorithmES256),
		CrvOrNOrK: []byte{1},
		XOrE:      goodP256X,
		Y:         goodP256Y,
	}

	goodP256Raw, err = em.Marshal(goodP256COSE)
	if err != nil {
		log.Fatalf("COSEKey marshal err: %v", err)
	}

	template := x509.Certificate{
		SerialNumber: big.NewInt(0),
		Version:      3,
		Subject: pkix.Name{
			Country:            []string{"US"},
			Organization:       []string{"Acme"},
			OrganizationalUnit: []string{"Authenticator Attestation"},
			CommonName:         "Wile E. Coyote",
		},
		Extensions: []pkix.Extension{
			{
				Id:       idFidoGenCeAaguid,
				Critical: false,
				Value: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
			},
		},
		IsCA: false,
	}

	goodP256CertBytes, err = x509.CreateCertificate(&predictableReader{}, &template, &template, &goodP256Key.PublicKey, goodP256Key)
	if err != nil {
		log.Fatal(err)
	}

	goodP256Cert, err = x509.ParseCertificate(goodP256CertBytes)
	if err != nil {
		log.Fatal(err)
	}

	mockCredentialID = "47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU"
	mockRawCredentialID, err = base64.RawURLEncoding.DecodeString(mockCredentialID)
	if err != nil {
		log.Fatalf("Credential ID decode err: %v", err)
	}

	mockCreateClientDataJSON = []byte(`{"type":"webauthn.create","challenge":"` + mockCredentialID + `","origin":"https://e3b0c442.io"}`)
	mockCreateClientDataJSONHash = sha256.Sum256(mockCreateClientDataJSON)

	mockCredential = &testCred{
		owner:     &testUser{},
		id:        mockRawCredentialID,
		publicKey: []byte(goodP256Raw),
		signCount: 0,
	}

	mockUser = &testUser{
		name: "jsmith",
		icon: "",
		id: []byte{
			0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,
			0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
			0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
			0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,
		},
		displayName: "John Smith",
		credentials: map[string]Credential{
			mockCredentialID: mockCredential,
		},
	}

	mockAttestedCredentialData = AttestedCredentialData{
		AAGUID: [16]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // authData.attestedCredentialData.aaguid
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // v
		},
		CredentialID: []byte{
			0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, // authData.attestedCredentialData.credentialID
			0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, // |
			0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, // |
			0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55, // v
		},
		CredentialPublicKey: goodP256Raw,
	}

	mockRawAttestedCredentialData = append([]byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // authData.attestedCredentialData.aaguid
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // v
		0x00, 0x20, // authData.attestedCredentialData.credentialIDLength = 32
		0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, // authData.attestedCredentialData.credentialID
		0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, // |
		0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, // |
		0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55, // v
	}, goodP256Raw...)

	mockRawAuthData = append([]byte{
		0xd8, 0x33, 0x51, 0x40, 0x80, 0xa0, 0xc7, 0x2b, //authdata.rpIDHash
		0x1e, 0xfa, 0x42, 0xb1, 0x8c, 0x96, 0xb9, 0x27, // |
		0x3e, 0x9f, 0x19, 0x3f, 0xa9, 0x80, 0xdb, 0x09, // |
		0xa0, 0x93, 0x33, 0x86, 0x5c, 0x2b, 0x32, 0xf3, // v
		0x41,                   // authData.Flags
		0x00, 0x00, 0x00, 0x01, // authData.SignCount
	}, mockRawAttestedCredentialData...)

	mockAuthData = AuthenticatorData{
		RPIDHash: [32]byte{
			0xd8, 0x33, 0x51, 0x40, 0x80, 0xa0, 0xc7, 0x2b, //authdata.rpIDHash
			0x1e, 0xfa, 0x42, 0xb1, 0x8c, 0x96, 0xb9, 0x27, // |
			0x3e, 0x9f, 0x19, 0x3f, 0xa9, 0x80, 0xdb, 0x09, // |
			0xa0, 0x93, 0x33, 0x86, 0x5c, 0x2b, 0x32, 0xf3, // v
		},
		UP:                     true,
		UV:                     false,
		AT:                     true,
		ED:                     false,
		SignCount:              1,
		AttestedCredentialData: mockAttestedCredentialData,
	}

	mockRawNoneAttestationObject = cbor.RawMessage{
		0xa3,             // map, 3 items
		0x63,             // text string, 3 chars
		0x66, 0x6d, 0x74, // "fmt"
		0x64,                   // text string, 4 chars
		0x6e, 0x6f, 0x6e, 0x65, // "none"
		0x67,                                     // text string, 7 chars
		0x61, 0x74, 0x74, 0x53, 0x74, 0x6d, 0x74, // "attStmt"
		0xa0,                                           // null
		0x68,                                           // text string, 8 chars
		0x61, 0x75, 0x74, 0x68, 0x44, 0x61, 0x74, 0x61, // "authData"
		0x58, 0xa4, // byte string, 164 chars
		0xd8, 0x33, 0x51, 0x40, 0x80, 0xa0, 0xc7, 0x2b, //authdata.rpIDHash
		0x1e, 0xfa, 0x42, 0xb1, 0x8c, 0x96, 0xb9, 0x27, // |
		0x3e, 0x9f, 0x19, 0x3f, 0xa9, 0x80, 0xdb, 0x09, // |
		0xa0, 0x93, 0x33, 0x86, 0x5c, 0x2b, 0x32, 0xf3, // v
		0x41,                   // authData.Flags
		0x00, 0x00, 0x00, 0x01, // authData.SignCount
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // authData.attestedCredentialData.aaguid
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // v
		0x00, 0x20, // authData.attestedCredentialData.credentialIDLength = 32
		0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, // authData.attestedCredentialData.credentialID
		0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, // |
		0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, // |
		0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55, // v
		0xa5, // map of 5 items
		0x1,  // key 1 (Kty)
		0x2,  // 2 (EC2 key)
		0x3,  // key 3 (Alg)
		0x26, // -7
		0x20, // key -1
		0x1,  // 1 (P256 Curve)
		0x21, // key -2
		0x58, // byte string, >24 bytes
		0x20, // 32 bytes length
		0x16, 0x16, 0xd7, 0xd0, 0x6a, 0x17, 0xd4, 0xff,
		0xbf, 0x16, 0x69, 0x3e, 0x6c, 0x60, 0x5, 0xe6,
		0xc7, 0x9, 0x16, 0x71, 0x6a, 0xf1, 0x3e, 0x95,
		0xc2, 0xf2, 0xda, 0xc8, 0x6, 0x7, 0x2e, 0x8d,
		0x22, // key -3
		0x58, // byte string, >24 bytes
		0x20, // 32 bytes length
		0xb6, 0x72, 0x4, 0x62, 0x42, 0x44, 0x45, 0x2b,
		0x96, 0x4f, 0x5c, 0xab, 0x16, 0x1c, 0xd3, 0xc,
		0x76, 0x72, 0x6b, 0x9b, 0x36, 0x1d, 0xca, 0xdc,
		0xda, 0x2, 0xef, 0x1a, 0x5c, 0x71, 0xac, 0x78,
	}

	goodFIDOU2FAttStmt = append([]byte{
		0xa2,             // map 2 items
		0x63,             // text string 3 chars
		0x73, 0x69, 0x67, // "sig"
		0x58, 0x46, // byte string, 70 bytes
		0x30, 0x44, 0x2, 0x20, 0x25, 0x6f, 0xab, 0x23,
		0xcf, 0xdc, 0x32, 0xd7, 0xd1, 0xb2, 0xef, 0x88,
		0xb7, 0x9a, 0xde, 0x4b, 0x16, 0x28, 0x82, 0x5f,
		0x2b, 0xa1, 0x89, 0x9d, 0x10, 0xa7, 0xc6, 0xbe,
		0xbc, 0xa3, 0x3a, 0xae, 0x2, 0x20, 0x45, 0x83,
		0x5d, 0x59, 0x5b, 0x7d, 0x33, 0x96, 0xa4, 0x4b,
		0x6f, 0x71, 0x9b, 0x67, 0xe3, 0xf1, 0x5d, 0x21,
		0x45, 0x2d, 0xc6, 0x30, 0x9, 0x3e, 0xc4, 0x84,
		0x7b, 0xa6, 0xd6, 0x8b, 0x25, 0x64,
		0x63,             // text string 3 chars
		0x78, 0x35, 0x63, // "x5c"
		0x81,             // array, 1 member
		0x59, 0x01, 0xab, // byte string, 427 bytes
	}, goodP256CertBytes...)

	goodPackedAttStmt = cbor.RawMessage(
		append([]byte{
			0xa3,             // map 2 items
			0x63,             // text string 3 chars
			0x61, 0x6c, 0x67, // "alg"
			0x26,             // bogus alg
			0x63,             // text string 3 chars
			0x73, 0x69, 0x67, // "sig"
			0x58, 0x48, // byte string, 72 bytes
			0x30, 0x46, 0x2, 0x21, 0x0, 0x96, 0x34, 0xfd,
			0xfe, 0x8c, 0x20, 0xb2, 0x46, 0xb7, 0x67, 0x21,
			0x67, 0xaa, 0x8a, 0x4c, 0xcd, 0x76, 0xcc, 0x84,
			0xf3, 0x42, 0x7f, 0xa4, 0x2e, 0x5e, 0x1e, 0x41,
			0x57, 0xc4, 0xd4, 0xfd, 0x31, 0x2, 0x21, 0x0,
			0xc2, 0x5e, 0xa0, 0xf, 0x21, 0x31, 0x33, 0xd3,
			0x1e, 0xbf, 0x34, 0x5e, 0x63, 0x6a, 0x9d, 0xcc,
			0x6f, 0xa, 0xfc, 0xd0, 0x94, 0x12, 0x8b, 0x85,
			0xd8, 0x7f, 0x8f, 0x5c, 0x9b, 0x49, 0xc9, 0x4a,
			0x63,             // text string 3 chars
			0x78, 0x35, 0x63, // "x5c"
			0x81,             // array, 1 member
			0x59, 0x01, 0xab, // byte string, 427 bytes
		}, goodP256CertBytes...),
	)

	mockRawPackedAttestationObject = cbor.RawMessage(
		append(
			append(
				[]byte{
					0xa3,             // map, 3 items
					0x63,             // text string, 3 chars
					0x66, 0x6d, 0x74, // "fmt"
					0x66,                               // text string, 6 chars
					0x70, 0x61, 0x63, 0x6b, 0x65, 0x64, // "packed"
					0x67,                                     // text string, 7 chars
					0x61, 0x74, 0x74, 0x53, 0x74, 0x6d, 0x74, // "attStmt"
				}, goodPackedAttStmt...),
			[]byte{
				0x68,                                           // text string, 8 chars
				0x61, 0x75, 0x74, 0x68, 0x44, 0x61, 0x74, 0x61, // "authData"
				0x58, 0xa4, // byte string, 164 chars
				0xd8, 0x33, 0x51, 0x40, 0x80, 0xa0, 0xc7, 0x2b, //authdata.rpIDHash
				0x1e, 0xfa, 0x42, 0xb1, 0x8c, 0x96, 0xb9, 0x27, // |
				0x3e, 0x9f, 0x19, 0x3f, 0xa9, 0x80, 0xdb, 0x09, // |
				0xa0, 0x93, 0x33, 0x86, 0x5c, 0x2b, 0x32, 0xf3, // v
				0x41,                   // authData.Flags
				0x00, 0x00, 0x00, 0x01, // authData.SignCount
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // authData.attestedCredentialData.aaguid
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // v
				0x00, 0x20, // authData.attestedCredentialData.credentialIDLength = 32
				0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, // authData.attestedCredentialData.credentialID
				0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, // |
				0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, // |
				0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55, // v
				0xa5, // map of 5 items
				0x1,  // key 1 (Kty)
				0x2,  // 2 (EC2 key)
				0x3,  // key 3 (Alg)
				0x26, // -7
				0x20, // key -1
				0x1,  // 1 (P256 Curve)
				0x21, // key -2
				0x58, // byte string, >24 bytes
				0x20, // 32 bytes length
				0x16, 0x16, 0xd7, 0xd0, 0x6a, 0x17, 0xd4, 0xff,
				0xbf, 0x16, 0x69, 0x3e, 0x6c, 0x60, 0x5, 0xe6,
				0xc7, 0x9, 0x16, 0x71, 0x6a, 0xf1, 0x3e, 0x95,
				0xc2, 0xf2, 0xda, 0xc8, 0x6, 0x7, 0x2e, 0x8d,
				0x22, // key -3
				0x58, // byte string, >24 bytes
				0x20, // 32 bytes length
				0xb6, 0x72, 0x4, 0x62, 0x42, 0x44, 0x45, 0x2b,
				0x96, 0x4f, 0x5c, 0xab, 0x16, 0x1c, 0xd3, 0xc,
				0x76, 0x72, 0x6b, 0x9b, 0x36, 0x1d, 0xca, 0xdc,
				0xda, 0x2, 0xef, 0x1a, 0x5c, 0x71, 0xac, 0x78,
			}...,
		),
	)

	mockRawFIDOU2FAttestationObject = append(
		append(
			[]byte{
				0xa3,             // map, 3 items
				0x63,             // text string, 3 chars
				0x66, 0x6d, 0x74, // "fmt"
				0x68,                                           // text string, 8 chars
				0x66, 0x69, 0x64, 0x6f, 0x2d, 0x75, 0x32, 0x66, // "fido-u2f"
				0x67,                                     // text string, 7 chars
				0x61, 0x74, 0x74, 0x53, 0x74, 0x6d, 0x74, // "attStmt"
			}, goodFIDOU2FAttStmt...),
		[]byte{
			0x68,                                           // text string, 8 chars
			0x61, 0x75, 0x74, 0x68, 0x44, 0x61, 0x74, 0x61, // "authData"
			0x58, 0xa4, // byte string, 164 chars
			0xd8, 0x33, 0x51, 0x40, 0x80, 0xa0, 0xc7, 0x2b, //authdata.rpIDHash
			0x1e, 0xfa, 0x42, 0xb1, 0x8c, 0x96, 0xb9, 0x27, // |
			0x3e, 0x9f, 0x19, 0x3f, 0xa9, 0x80, 0xdb, 0x09, // |
			0xa0, 0x93, 0x33, 0x86, 0x5c, 0x2b, 0x32, 0xf3, // v
			0x41,                   // authData.Flags
			0x00, 0x00, 0x00, 0x01, // authData.SignCount
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // authData.attestedCredentialData.aaguid
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // v
			0x00, 0x20, // authData.attestedCredentialData.credentialIDLength = 32
			0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, // authData.attestedCredentialData.credentialID
			0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, // |
			0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, // |
			0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55, // v
			0xa5, // map of 5 items
			0x1,  // key 1 (Kty)
			0x2,  // 2 (EC2 key)
			0x3,  // key 3 (Alg)
			0x26, // -7
			0x20, // key -1
			0x1,  // 1 (P256 Curve)
			0x21, // key -2
			0x58, // byte string, >24 bytes
			0x20, // 32 bytes length
			0x16, 0x16, 0xd7, 0xd0, 0x6a, 0x17, 0xd4, 0xff,
			0xbf, 0x16, 0x69, 0x3e, 0x6c, 0x60, 0x5, 0xe6,
			0xc7, 0x9, 0x16, 0x71, 0x6a, 0xf1, 0x3e, 0x95,
			0xc2, 0xf2, 0xda, 0xc8, 0x6, 0x7, 0x2e, 0x8d,
			0x22, // key -3
			0x58, // byte string, >24 bytes
			0x20, // 32 bytes length
			0xb6, 0x72, 0x4, 0x62, 0x42, 0x44, 0x45, 0x2b,
			0x96, 0x4f, 0x5c, 0xab, 0x16, 0x1c, 0xd3, 0xc,
			0x76, 0x72, 0x6b, 0x9b, 0x36, 0x1d, 0xca, 0xdc,
			0xda, 0x2, 0xef, 0x1a, 0x5c, 0x71, 0xac, 0x78,
		}...,
	)

	mockNoneAttestationObject = AttestationObject{
		AuthData: mockAuthData,
		Fmt:      AttestationFormatNone,
		AttStmt:  cbor.RawMessage{0xa0},
	}

	os.Exit(m.Run())
}

func TestSupportedKeyAlgorithms(t *testing.T) {
	algs := SupportedKeyAlgorithms()
	if !reflect.DeepEqual(algs, []COSEAlgorithmIdentifier{
		AlgorithmEdDSA,
		AlgorithmES512,
		AlgorithmES384,
		AlgorithmES256,
		AlgorithmPS512,
		AlgorithmPS384,
		AlgorithmPS256,
		AlgorithmRS512,
		AlgorithmRS384,
		AlgorithmRS256,
		AlgorithmRS1,
	}) {
		t.Fatal("Unexpected result")
	}
}

func TestSupportedAttestationStatementFormats(t *testing.T) {
	fmts := SupportedAttestationStatementFormats()
	if !reflect.DeepEqual(fmts, []AttestationStatementFormat{
		AttestationFormatNone,
	}) {
		t.Fatal("Unexpected result")
	}
}
